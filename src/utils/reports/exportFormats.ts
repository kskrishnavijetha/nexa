
import { jsPDF } from 'jspdf';
import { ComplianceReport } from '../types';
import { saveAs } from 'file-saver';

/**
 * Export formats supported by the application
 */
export type ExportFormat = 'pdf' | 'docx' | 'csv';

/**
 * Sanitize filename by removing invalid characters
 */
const sanitizeFilename = (filename: string): string => {
  return filename.replace(/[^a-z0-9]/gi, '-').toLowerCase();
};

/**
 * Generate a standardized filename with current date for the report
 */
export const generateReportFilename = (report: ComplianceReport, format: ExportFormat): string => {
  const date = new Date();
  const formattedDate = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
  const sanitizedName = sanitizeFilename(report.documentName);
  
  return `${sanitizedName}-compliance-report-${formattedDate}.${format}`;
};

/**
 * Export compliance report as CSV
 */
export const exportReportAsCSV = (report: ComplianceReport): void => {
  // Headers for CSV
  let csvContent = "Title,Category,Severity,Description,Regulation,Mitigation\n";
  
  // Add risks to CSV
  report.risks.forEach(risk => {
    // Escape commas and quotes in fields
    const safeDescription = risk.description.replace(/"/g, '""');
    const safeMitigation = (risk.mitigation || '').replace(/"/g, '""');
    csvContent += `"${risk.title}","Risk","${risk.severity}","${safeDescription}","${risk.regulation || ''}","${safeMitigation}"\n`;
  });
  
  // Create blob and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const filename = generateReportFilename(report, 'csv');
  saveAs(blob, filename);
};

/**
 * Export compliance report as DOCX (simplified version)
 * Note: This is a placeholder that creates a simple text file with .docx extension
 * A full implementation would require a library like docx.js
 */
export const exportReportAsDOCX = (report: ComplianceReport): void => {
  // Create a simple text representation
  let content = `Compliance Report: ${report.documentName}\n`;
  content += `Date: ${new Date().toLocaleDateString()}\n\n`;
  content += `Industry: ${report.industry || 'N/A'}\n`;
  content += `Overall Score: ${report.overallScore}%\n\n`;
  
  content += "Compliance Issues:\n";
  report.risks.forEach((risk, index) => {
    content += `${index + 1}. ${risk.title} - ${risk.severity.toUpperCase()}\n`;
    content += `   Description: ${risk.description}\n`;
    content += `   Regulation: ${risk.regulation || 'N/A'}\n`;
    content += `   Mitigation: ${risk.mitigation || 'N/A'}\n\n`;
  });
  
  content += "\nGenerated by Nexabloom (nexabloom.xyz)";
  
  // Create blob and download using saveAs for consistent behavior
  const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
  const filename = generateReportFilename(report, 'docx');
  saveAs(blob, filename);
};

/**
 * Export PDF using the existing generateReportPDF function
 */
export const exportReportAsPDF = async (report: ComplianceReport, chartImageBase64?: string): Promise<void> => {
  // Import dynamically to avoid circular dependencies
  const { generateReportPDF } = await import('./generateReportPDF');
  
  try {
    const response = await generateReportPDF(report, 'en', chartImageBase64);
    
    if (response.success && response.data) {
      // Use saveAs for consistent behavior across formats
      const filename = generateReportFilename(report, 'pdf');
      saveAs(response.data, filename);
    } else {
      console.error('Failed to generate PDF:', response.error);
      throw new Error(response.error || 'Failed to generate PDF');
    }
  } catch (error) {
    console.error('Error exporting as PDF:', error);
    throw error;
  }
};

/**
 * Main export function that handles all formats
 */
export const exportReport = async (report: ComplianceReport, format: ExportFormat, chartImageBase64?: string): Promise<void> => {
  try {
    console.log(`[exportReport] Exporting report in ${format} format`);
    
    switch (format) {
      case 'csv':
        exportReportAsCSV(report);
        break;
      case 'docx':
        exportReportAsDOCX(report);
        break;
      case 'pdf':
        await exportReportAsPDF(report, chartImageBase64);
        break;
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  } catch (error) {
    console.error(`Error exporting report as ${format}:`, error);
    throw error;
  }
};
